# Тестовое задание
## Часть 1: Серверная часть на Go (Backend)  
### 1. Разработка API    

Ссылка на репозиторий с приложением:
https://github.com/Egori/userlist-api-go-test
Использовано ORM Gorm, для миграции задействовано Gorm AutoMigrate.
Написаны тесты для методов сервисного слоя, с мокированием репозитория, а также для тестов с подключением тестовой БД.

### 2. Оптимизация кода

 Оптимизация производительности API для работы с большим объемом данных требует всестороннего подхода, включающего оптимизацию базы данных, кода и инфраструктуры.
####  Оптимизация базы данных
##### Индексация
Необходимо создать индексы в базе данных на колонки, используемые в фильтрации и сортировке, такие как ID, name, Email. Например:
```sql
CREATE INDEX idx_name ON users (name);  
CREATE INDEX idx_email ON users (email);  
CREATE INDEX idx_id ON users (id);  
```
Если используется Gorm,как в нашем случае, индексы прописываются в структуре модели:
```go
type User struct {
	gorm.Model
	Name  string `json:"name" gorm:"size:100;not null;index"`
	Email string `json:"email" gorm:"size:255;not null;unique"`
}
```

При этом индексы будут созданы автоматически в базе данных при создании таблицы.
```go
    db.AutoMigrate(&User{})
```

##### Шардирование
При огромных объемах данных (>10 млн записей) можно рассмотреть горизонтальное шардирование, например, по возрасту или географическому региону.

#### Оптимизация приложения
##### Пагинация
Вместо возврата всех записей в ответе, потребуется реализовать пагинацию. Например:
```go
func (r *userRepository) GetPaginated(limit, offset int) ([]models.User, error) {
    var users []models.User
    err := r.db.Limit(limit).Offset(offset).Find(&users).Error
    return users, err
}
```
##### Кэширование
Кэширование часто запрашиваемых данных в Redis или Memcached поможет ускорить доступ к данным и уменьшить нагрузку на базу данных.

##### Batch Updates
выполнение операций с большим объемом данных производится партиями:
for _, user := range users {
    db.Model(&user).Updates(map[string]interface{}{"age": 30})
}

#####  Сжатие данных
Cжатие HTTP-ответов через middleware, например, gzip:
```go
import	"github.com/labstack/echo/v4/middleware"

	e := echo.New()

	// Добавляем middleware для сжатия
	e.Use(middleware.CompressWithConfig(middleware.CompressConfig{
		Level: middleware.DefaultCompressionLevel, // Уровень сжатия
	}))
  ```
  
  #### Инфраструктура
##### Вертикальное масштабирование
Обеспечить достаточное количество ресурсов ссервера (RAM, CPU).
##### Горизонтальное масштабирование и балансировка нагрузки баз данных.
Создать реплики базы данных для распределения нагрузки на чтение.
Балансировка нагрузки с репликами может быть реализована:  
 - В приложении (самостоятельное распределение запросов).
 - Через прокси (ProxySQL, Pgpool-II).
 - На уровне драйвера базы данных.
##### Балансировка нагрузки
Использовать Load Balancer (например, настроив Nginx) для распределения запросов между несколькими экземплярами API.